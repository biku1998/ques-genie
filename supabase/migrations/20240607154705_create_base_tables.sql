create extension if not exists moddatetime schema extensions;

create table public.users (
    id uuid not null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone null,
    name text not null,
    email text not null,
    avatar_url text null,
    is_active boolean not null default true,
    constraint users_pkey primary key (id),
    constraint users_email_key unique (email),
    constraint users_id_fkey foreign key (id) references auth.users (id) on delete cascade
) tablespace pg_default;

alter table if exists public.users enable row level security;
create policy self on public.users as permissive for all to public using ((auth.uid() = id))
with check ((auth.uid() = id));

create trigger
  handle_updated_at before update
on public.users
for each row execute
  procedure moddatetime(updated_at);

-- insert a row in public.users when a new user is created in auth.users
create function public.create_public_user_for_auth_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.users(id, email, name) 
  values 
  (new.id, new.email, 'Pied piper');
  return new;
end;
$$;

-- trigger
create trigger create_public_user_for_auth_user
  after insert on auth.users
  for each row execute procedure public.create_public_user_for_auth_user();

create table public.labels (
    id bigint generated by default as identity,
    text text not null,
    created_by uuid not null,
    created_at timestamp with time zone not null default now(),
    constraint labels_pkey primary key (id),
    constraint labels_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade
) tablespace pg_default;

alter table if exists public.labels enable row level security;
create policy ownership on public.labels as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));

create table public.sessions (
    id uuid not null default gen_random_uuid(),
    title text not null,
    description text null,
    source_text text null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone null,
    created_by uuid not null,
    constraint sessions_pkey primary key (id),
    constraint sessions_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade
) tablespace pg_default;

alter table if exists public.sessions enable row level security;
create policy ownership on public.sessions as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));

create trigger
  handle_updated_at before update
on public.sessions
for each row execute
  procedure moddatetime(updated_at);

create table public.session_labels (
    id bigint generated by default as identity,
    label_id bigint not null,
    session_id uuid not null,
    created_at timestamp with time zone not null default now(),
    created_by uuid not null,
    constraint session_labels_pkey primary key (id),
    constraint session_labels_label_id_fkey foreign key (label_id) references public.labels (id) on delete cascade,
    constraint session_labels_session_id_fkey foreign key (session_id) references public.sessions (id) on delete cascade,
    constraint session_labels_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade
) tablespace pg_default;

alter table if exists public.session_labels enable row level security;
create policy ownership on public.session_labels as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));

create table public.session_topics (
    id bigint generated by default as identity,
    text text not null,
    session_id uuid not null,
    created_at timestamp with time zone not null default now(),
    created_by uuid not null,
    constraint session_topics_pkey primary key (id),
    constraint session_topics_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade,
    constraint session_topics_session_id_fkey foreign key (session_id) references public.sessions (id) on delete cascade
) tablespace pg_default;

alter table if exists public.session_topics enable row level security;
create policy ownership on public.session_topics as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));

create type public.question_level as enum ('EASY', 'MEDIUM', 'HARD');

create type public.question_type as enum ('RADIO', 'CHECKBOX');

create table public.session_question_configs (
    id bigint generated by default as identity,
    session_id uuid not null,
    level public.question_level not null,
    type public.question_type not null,
    count integer not null,
    topic_id bigint not null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone null,
    created_by uuid not null,
    constraint session_question_configs_pkey primary key (id),
    constraint session_question_configs_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade,
    constraint session_question_configs_session_id_fkey foreign key (session_id) references public.sessions (id) on delete cascade,
    constraint session_question_configs_topic_id_fkey foreign key (topic_id) references public.session_topics (id) on delete cascade
) tablespace pg_default;

alter table if exists public.session_question_configs enable row level security;
create policy ownership on public.session_question_configs as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));

create trigger
  handle_updated_at before update
on public.session_question_configs
for each row execute
  procedure moddatetime(updated_at);

create table public.session_questions(
    id bigint generated by default as identity,
    session_id uuid not null,
    topic_id bigint not null,
    text text not null,
    level public.question_level not null,
    type public.question_type not null,
    payload jsonb not null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone null,
    created_by uuid not null,
    constraint questions_pkey primary key (id),
    constraint session_question_configs_session_id_fkey foreign key (session_id) references public.sessions (id) on delete cascade,
    constraint session_question_configs_topic_id_fkey foreign key (topic_id) references public.session_topics (id) on delete cascade,
    constraint questions_created_by_fkey foreign key (created_by) references public.users (id) on delete cascade
) tablespace pg_default;

alter table if exists public.session_questions enable row level security;
create policy ownership on public.session_questions as permissive for all to public using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));


create trigger
  handle_updated_at before update
on public.session_questions
for each row execute
  procedure moddatetime(updated_at);